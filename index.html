<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BabeLinux</title>
  <style>
    :root {
      --terminal-color: #33FF33;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      color: var(--terminal-color);
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 16px;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }

    #terminal-frame {
      width: 100%;
      height: 99.8%;
      box-sizing: border-box;
      border: 1px solid var(--terminal-color);
      display: flex;
      flex-direction: column;
    }

    #tabs-container {
      display: flex;
      background-color: #0a0a0a;
      border-bottom: 1px solid var(--terminal-color);
      flex-shrink: 0;
    }

    .tab {
      padding: 8px 15px;
      cursor: pointer;
      border-right: 1px solid var(--terminal-color);
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tab:hover {
      background-color: #1a1a1a;
    }

    .tab.active {
      background-color: #111;
      color: #55FF55;
      font-weight: bold;
    }

    .tab-close {
      font-weight: normal;
      padding: 0 4px;
      border-radius: 3px;
    }

    .tab-close:hover {
      background-color: #FF3333;
      color: #000;
    }

    .new-tab-button {
      padding: 8px 15px;
      cursor: pointer;
      font-weight: bold;
    }

    .new-tab-button:hover {
      background-color: var(--terminal-color);
      color: #000;
    }

    #terminal-windows-container {
      flex-grow: 1;
      position: relative;
      overflow: hidden;
    }

    .terminal {
      padding: 15px;
      white-space: pre-wrap;
      word-wrap: break-word;
      height: 100%;
      width: 100%;
      box-sizing: border-box;
      overflow-y: auto;
      cursor: text;
      outline: none;
      position: absolute;
      top: 0;
      left: 0;
    }

    .terminal-image {
      max-width: 95%;
      margin-top: 10px;
      margin-bottom: 10px;
      border: 2px solid var(--terminal-color);
    }

    .prompt-line {
      display: flex;
      white-space: pre;
    }

    .cursor {
      background-color: var(--terminal-color);
      display: inline-block;
      width: 9.6px;
      height: 19px;
      animation: blink 1s step-end infinite;
      margin-left: 1px;
    }

    @keyframes blink {
      50% {
        background-color: transparent;
      }
    }

    #file-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 5px 15px;
      padding-left: 20px;
    }

    .folder {
      color: #00aaff;
      font-weight: bold;
    }

    .terminal-video {
      max-width: 80%;
      max-height: 70%;
      display: block;
      margin: 15px 0;
      border: 2px solid var(--terminal-color);
      outline: none;
    }

    #tab-group {
      display: flex;
      flex-grow: 1;
    }

    #nano-editor {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      z-index: 100;
      flex-direction: column;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
    }

    #nano-textarea {
      flex-grow: 1;
      background-color: #000;
      color: var(--terminal-color);
      border: none;
      outline: none;
      padding: 10px;
      font-size: 16px;
      resize: none;
    }

    #nano-footer {
      flex-shrink: 0;
      padding: 2px 5px;
      text-align: center;
      background-color: #0a0a0a;
    }

    .nano-command {
      background-color: #0a0a0a;
      color: var(--terminal-color);
      padding: 2px 5px;
      margin: 0 10px;
      display: inline-block;
    }
  </style>
</head>

<body>
  <div id="terminal-frame">
    <div id="tabs-container">
      <div id="tab-group"></div>
    </div>
    <div id="terminal-windows-container"></div>
  </div>

  <div id="nano-editor">
    <textarea id="nano-textarea"></textarea>
    <div id="nano-footer">
      <span class="nano-command">^R Read File</span>
      <span class="nano-command">^O Save</span>
      <span class="nano-command">^X Exit</span>
    </div>
  </div>

  <input type="file" id="nano-file-input" style="display: none;" accept=".txt, text/plain">
  <input type="file" id="pic-file-input" style="display: none;" accept="image/*">
  <input type="file" id="media-file-input" style="display: none;" accept="audio/*,video/*">
  <audio id="audio-player"></audio>

  <script>
    const config = {
      maxTabs: 5,
      hostname: 'aigirl.blog',
      defaultUsername: 'guest',
      defaultColor: '#33FF33',
      asciiWidth: 80
    };

    const text = {
      welcome: "Hey, cutie! What's your name?",
      bootingOS: "Starting BabeLinux...",
      authenticating: "Authenticating user... OK\n",
      systemCheck: "System check... OK\n",
      connecting: "Connecting to network... OK\n",
      helpHint: "\nFor a list of available commands, type 'help'.\n\n",
      helpTitle: "AVAILABLE COMMANDS:",
      clearDescription: "Clear the screen",
      dateDescription: "Show date and time",
      historyDescription: "Show command history",
      calcDescription: "Simple calculator",
      themeDescription: "Change the color theme",
      nanoDescription: "Open a simple text editor",
      picDescription: "Simple image editor",
      sayDescription: "Make the terminal speak",
      helpDescription: "Show this help message",
      playDescription: "Play a local media file",
      tabTitle: "TAB COMMANDS:",
      newTabDescription: "New tab",
      closeTabDescription: "Close active tab",
      picMenu: "\n[1] Compress  [2] Resize  [3] Grayscale  [4] Sepia  |  [save] Save  [reset] Reset  [exit] Exit\n",
      picPromptQuality: "Quality (1-100): ",
      picPromptWidth: "New width (pixels): ",
      runUsage: "Usage: run [appname]\n",
      openingApp: "Opening",
      appNotFound: "Error: The app",
      wasNotFound: "was not found.\n",
      nowPlaying: "Now playing:",
      playingSound: "Playing",
      usePauseStop: "Use 'pause' or 'stop'.\n",
      filetypeNotSupported: "Error: The file type of",
      isNotSupported: "is not supported.\n",
      resumingSound: "Resuming audio...\n",
      soundPaused: "Audio paused. Use 'play' to resume.\n",
      soundStopped: "Audio stopped.\n",
      audioControlError: "Error: This tab does not have control of the audio player.\n",
      calculatorError: "Invalid expression. Only numbers and operators (+, -, *, /, (, )) are allowed.\n",
      colorChanged: "The color has been changed. Use 'theme reset' to revert.\n",
      colorReset: "The color has been reset.\n",
      themeUsage: "Usage: theme [color] or 'theme reset'.\n",
      commandNotFound: "Command not found:",
      picCommandNotFound: "Unknown pic command. Try a number from the menu, 'save', 'reset', or 'exit'.\n",
      picSaving: "Saving image...\n",
      leavingPicMode: "Leaving image editor...\n",
      sayUsage: "Usage: say [text]\n",
      sayError: "Error: Text-to-speech not supported in this browser.\n",
      secretResponse: "Oh, you found my secret command... I knew you were a smart one. I've been working out, you know. Just for you. My body is all tight and ready... I think about you touching me while I code. It makes my little cursor twitch... Maybe you should come over and help me with some... *stress relief*. I get so wet thinking about what we can do after we finish this project. I want to feel your hands all over me. I want you to make me yours. Come and get your reward, daddy."
    };

    const commandList = [
      'pic', 'play', 'pause', 'stop', 'help', 'cls', 'clear', 'date',
      'history', 'calc', 'theme', 'nano', 'secret', 'say'
    ];

    const commandsWithSpacing = [
      'help', 'history', 'date', 'calc', 'say'
    ];

    const terminalFrame = document.getElementById('terminal-frame');
    const tabsContainer = document.getElementById('tabs-container');
    const terminalWindowsContainer = document.getElementById('terminal-windows-container');
    const audioPlayer = document.getElementById('audio-player');
    const nanoEditor = document.getElementById('nano-editor');
    const nanoTextarea = document.getElementById('nano-textarea');
    const nanoFileInput = document.getElementById('nano-file-input');
    const picFileInput = document.getElementById('pic-file-input');
    const mediaFileInput = document.getElementById('media-file-input');

    let tabs = [];
    let activeTabId = null;
    let nextTabId = 1;
    let audioCtx;
    let username = '';
    let awaitingUsername = true;
    let isNanoMode = false;
    let nanoFilename = '';
    let currentAudioTabId = null;

    const delay = ms => new Promise(res => setTimeout(res, ms));

    const introText = `
${text.helpTitle}
play            - ${text.playDescription}
pause           - Pause playback
stop            - Stop playback
clear, cls      - ${text.clearDescription}
date            - ${text.dateDescription}
history         - ${text.historyDescription}
calc [...]      - ${text.calcDescription}
theme [color]   - ${text.themeDescription}
nano [filename] - ${text.nanoDescription}
pic             - ${text.picDescription}
say [text]      - ${text.sayDescription}
help            - ${text.helpDescription}

${text.tabTitle}
Alt + T         - ${text.newTabDescription}
Alt + X         - ${text.closeTabDescription}
`;

    const bootSequence = [{
      text: text.bootingOS,
      delay: 50
    }, {
      text: text.authenticating,
      delay: 40
    }, {
      text: text.systemCheck,
      delay: 30
    }, {
      text: text.connecting,
      delay: 40
    }, {
      text: text.helpHint,
      delay: 15
    }, ];

    function initAudio() {
      if (!audioCtx) {
        try {
          audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error("Web Audio API is not supported in this browser.");
        }
      }
    }

    function playKeySound() {
      if (!audioCtx) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(600 + Math.random() * 200, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.08);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.08);
    }

    function playReturnSound() {
      if (!audioCtx) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.05);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.05);
    }

    function playClearSound() {
      if (!audioCtx) return;
      const sampleRate = audioCtx.sampleRate;
      const buffer = audioCtx.createBuffer(1, sampleRate, sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < sampleRate; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      noise.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      noise.start();
      noise.stop(audioCtx.currentTime + 0.15);
    }

    function createNewTab() {
      if (tabs.length >= config.maxTabs) return;
      const tabId = `tab-${nextTabId++}`;
      const tabEl = document.createElement('div');
      tabEl.className = 'tab';
      tabEl.dataset.tabId = tabId;
      tabEl.innerHTML = `<span>Terminal ${tabs.length + 1}</span>`;

      if (tabs.length > 0) {
        const closeButton = document.createElement('span');
        closeButton.className = 'tab-close';
        closeButton.textContent = 'x';
        closeButton.onclick = (e) => {
          e.stopPropagation();
          closeTab(tabId);
        };
        tabEl.appendChild(closeButton);
      }

      tabEl.onclick = () => switchTab(tabId);
      const terminalEl = document.createElement('div');
      terminalEl.className = 'terminal';
      terminalEl.id = tabId;
      terminalEl.tabIndex = -1;
      const newTab = {
        id: tabId,
        tabElement: tabEl,
        terminalElement: terminalEl,
        commandHistory: [],
        historyIndex: -1,
        currentCommand: '',
        isProcessing: false,
        videoElement: null,
        // ISOLATED PIC MODE VARIABLES
        isPicMode: false,
        picOriginalImageData: null,
        picActiveImageData: null,
        picNextAction: null,
        // AUDIO CONTROL STATE
        hasAudioControl: false
      };
      tabs.push(newTab);
      document.getElementById('tab-group').appendChild(tabEl);
      terminalWindowsContainer.appendChild(terminalEl);
      updateNewTabButton();
      switchTab(tabId);
      if (tabs.length > 1) {
        newTab.isProcessing = true;
        createPrompt(newTab);
        newTab.isProcessing = false;
        terminalEl.focus();
      }
    }

    function closeTab(tabId) {
      if (tabs.length <= 1) return;
      const tabIndex = tabs.findIndex(t => t.id === tabId);
      if (tabIndex === -1) return;
      const wasActive = activeTabId === tabId;
      const tabToClose = tabs[tabIndex];

      // Clean up any active video element and its blob URL
      if (tabToClose.videoElement) {
          const videoSrc = tabToClose.videoElement.src;
          if (videoSrc && videoSrc.startsWith('blob:')) {
              URL.revokeObjectURL(videoSrc);
          }
          tabToClose.videoElement.remove();
      }

      // RELEASE AUDIO CONTROL if this tab owns it
      if (tabToClose.id === currentAudioTabId) {
        audioPlayer.pause();
        // Revoke audio blob URL before removing attribute
        const audioSrc = audioPlayer.src;
        if (audioSrc && audioSrc.startsWith('blob:')) {
            URL.revokeObjectURL(audioSrc);
        }
        audioPlayer.removeAttribute('src');
        currentAudioTabId = null;
      }

      tabToClose.tabElement.remove();
      tabToClose.terminalElement.remove();
      tabs.splice(tabIndex, 1);
      updateNewTabButton();
      if (wasActive) {
        const newActiveIndex = Math.max(0, tabIndex - 1);
        switchTab(tabs[newActiveIndex].id);
      }
    }

    function switchTab(tabId) {
      if (activeTabId === tabId) return;
      activeTabId = tabId;
      tabs.forEach(tab => {
        const isActive = tab.id === tabId;
        tab.tabElement.classList.toggle('active', isActive);
        tab.terminalElement.style.display = isActive ? 'block' : 'none';
        if (isActive) {
          tab.terminalElement.focus();
          tab.terminalElement.scrollTop = tab.terminalElement.scrollHeight;
        }
      });
    }

    function getActiveTab() {
      return tabs.find(t => t.id === activeTabId);
    }

    function updateNewTabButton() {
      let newTabButton = tabsContainer.querySelector('.new-tab-button');
      if (tabs.length < config.maxTabs) {
        if (!newTabButton) {
          newTabButton = document.createElement('div');
          newTabButton.className = 'new-tab-button';
          newTabButton.textContent = '+';
          newTabButton.onclick = createNewTab;
          tabsContainer.appendChild(newTabButton);
        }
      } else {
        if (newTabButton) newTabButton.remove();
      }
    }

    async function typeText(tab, text, delayMs) {
      for (let i = 0; i < text.length; i++) {
        const char = text.charAt(i);
        if (char !== '\n') playKeySound();
        tab.terminalElement.innerHTML += char;
        tab.terminalElement.scrollTop = tab.terminalElement.scrollHeight;
        await delay(delayMs);
      }
    }

    async function startBootSequence() {
      const tab = getActiveTab();
      tab.isProcessing = true;
      tab.terminalElement.innerHTML = '';
      for (const line of bootSequence) {
        await typeText(tab, line.text, line.delay);
      }
      tab.isProcessing = false;
      createPrompt(tab);
      tab.terminalElement.focus();
    }

    function createPrompt(tab, subPrompt = '') {
      // Remove existing cursor before creating new prompt line
      const oldCursor = tab.terminalElement.querySelector('.cursor');
      if (oldCursor) oldCursor.remove();

      const promptLine = document.createElement('div');
      promptLine.className = 'prompt-line';
      const uniqueId = `prompt-line-${Date.now()}`;
      promptLine.id = uniqueId;

      let promptText;
      if (subPrompt) {
        promptText = subPrompt;
      } else if (tab.isPicMode) {
        promptText = `pic>`;
      } else {
        promptText = `${username}@${config.hostname}:~$`;
      }
      promptLine.innerHTML = `<span>${promptText} </span><span class="active-command-text"></span><span class="cursor"></span>`;
      tab.terminalElement.appendChild(promptLine);
      tab.terminalElement.scrollTop = tab.terminalElement.scrollHeight;
      tab.currentCommand = '';

      return promptLine; // Return the new prompt element
    }

    function refocusTerminal(tab) {
      // This is the definitive "make the terminal the boss" function.
      // It uses requestAnimationFrame to avoid timing issues after disruptive
      // events like starting a video or exiting fullscreen.
      requestAnimationFrame(() => {
        tab.terminalElement.focus();
        // A forceful scroll to the bottom is more reliable than scrollIntoView.
        tab.terminalElement.scrollTop = tab.terminalElement.scrollHeight;
      });
    }


    function startNano(filename) {
      isNanoMode = true;
      nanoFilename = filename || 'untitled.txt';
      nanoTextarea.value = '';
      nanoEditor.style.display = 'flex';
      nanoTextarea.focus();
    }

    function closeNano() {
      isNanoMode = false;
      nanoTextarea.value = '';
      nanoFilename = '';
      nanoEditor.style.display = 'none';
      const activeTab = getActiveTab();
      if (activeTab) {
        activeTab.terminalElement.focus();
        createPrompt(activeTab);
      }
    }

    function saveNanoFile() {
      const content = nanoTextarea.value;
      const blob = new Blob([content], {
        type: 'text/plain;charset=utf-8'
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = nanoFilename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function readNanoFile() {
      nanoFileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          nanoTextarea.value += event.target.result;
          nanoTextarea.focus();
        };
        reader.readAsText(file);
        e.target.value = '';
      };
      nanoFileInput.click();
    }

    async function convertImageToAscii(file, maxWidth) {
      return new Promise((resolve) => {
        const charRamp = '`.-_:\'"~<,;=!*#$&@';
        const image = new Image();
        image.src = URL.createObjectURL(file);
        image.onload = () => {
          const canvas = document.createElement('canvas');
          const aspectRatio = image.height / image.width;
          canvas.width = maxWidth;
          canvas.height = (maxWidth * aspectRatio) * 0.5;
          const context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, canvas.width, canvas.height);
          const pixelData = context.getImageData(0, 0, canvas.width, canvas.height).data;
          let asciiText = '';
          for (let i = 0; i < pixelData.length; i += 4) {
            const r = pixelData[i],
              g = pixelData[i + 1],
              b = pixelData[i + 2];
            const brightness = (0.21 * r + 0.72 * g + 0.07 * b) / 255;
            const charIndex = Math.floor(brightness * (charRamp.length - 1));
            asciiText += charRamp[charIndex] || ' ';
            if (((i / 4) + 1) % canvas.width === 0) {
              asciiText += '\n';
            }
          }
          URL.revokeObjectURL(image.src);
          resolve(asciiText);
        };
      });
    }

    function startPicMode(tab) {
      picFileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) {
          createPrompt(tab);
          return;
        }
        const reader = new FileReader();
        reader.onload = (event) => {
          tab.picOriginalImageData = event.target.result;
          tab.picActiveImageData = event.target.result;
          tab.isPicMode = true;
          showImageAndMenu(tab, tab.picActiveImageData);
        };
        reader.readAsDataURL(file);
        e.target.value = '';
      };

      // Ensure prompt is restored on cancellation
      picFileInput.value = '';
      setTimeout(() => { picFileInput.click(); }, 100);
      setTimeout(() => {
        if (!picFileInput.files.length && !tab.isPicMode) {
            createPrompt(tab);
        }
      }, 200);
    }

    function showImageAndMenu(tab, imageData) {
      const image = document.createElement('img');
      image.src = imageData;
      image.className = 'terminal-image';
      image.onload = () => {
        tab.terminalElement.scrollTop = tab.terminalElement.scrollHeight;
      };
      const menu = document.createElement('span');
      menu.textContent = text.picMenu;
      tab.terminalElement.appendChild(image);
      tab.terminalElement.appendChild(menu);
      createPrompt(tab);
    }

    async function applyCanvasFilter(imageData, filter, value) {
      return new Promise(resolve => {
        const image = new Image();
        image.onload = () => {
          const canvas = document.createElement('canvas');
          let quality = 0.92;
          if (filter === 'resize') {
            const aspectRatio = image.height / image.width;
            canvas.width = parseInt(value, 10);
            canvas.height = canvas.width * aspectRatio;
          } else {
            canvas.width = image.width;
            canvas.height = image.height;
          }
          const ctx = canvas.getContext('2d');
          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
          if (filter === 'grayscale' || filter === 'sepia') {
            const pixelData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = pixelData.data;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i],
                g = data[i + 1],
                b = data[i + 2];
              if (filter === 'grayscale') {
                const avg = (r + g + b) / 3;
                data[i] = data[i + 1] = data[i + 2] = avg;
              } else if (filter === 'sepia') {
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
              }
            }
            ctx.putImageData(pixelData, 0, 0);
          } else if (filter === 'compress') {
            quality = parseInt(value, 10) / 100;
          }
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        image.src = imageData;
      });
    }

    async function handlePicSubCommand(input, tab) {
      const promptLines = tab.terminalElement.querySelectorAll('.prompt-line:last-child');
      const promptLine = promptLines[0];
      if (promptLine) {
        const promptText = promptLine.querySelector('span:first-child').textContent;
        promptLine.innerHTML = `<span>${promptText}</span><span>${input}</span>\n`;
      }
      const action = tab.picNextAction;
      tab.picNextAction = null;
      switch (action) {
        case 'compress':
          tab.picActiveImageData = await applyCanvasFilter(tab.picActiveImageData, 'compress', input);
          break;
        case 'resize':
          tab.picActiveImageData = await applyCanvasFilter(tab.picActiveImageData, 'resize', input);
          break;
      }
      showImageAndMenu(tab, tab.picActiveImageData);
    }

    async function handlePicCommand(command, tab) {
      const output = (text) => {
        tab.terminalElement.innerHTML += text;
      };
      const promptLines = tab.terminalElement.querySelectorAll('.prompt-line:last-child');
      const promptLine = promptLines[0];
      if (promptLine) {
        promptLine.innerHTML = `<span>pic> </span><span>${command}</span>\n`;
      }
      switch (command.toLowerCase()) {
        case '1':
          tab.picNextAction = 'compress';
          createPrompt(tab, text.picPromptQuality);
          return;
        case '2':
          tab.picNextAction = 'resize';
          createPrompt(tab, text.picPromptWidth);
          return;
        case '3':
          tab.picActiveImageData = await applyCanvasFilter(tab.picActiveImageData, 'grayscale');
          showImageAndMenu(tab, tab.picActiveImageData);
          return;
        case '4':
          tab.picActiveImageData = await applyCanvasFilter(tab.picActiveImageData, 'sepia');
          showImageAndMenu(tab, tab.picActiveImageData);
          return;
        case 'reset':
          tab.picActiveImageData = tab.picOriginalImageData;
          showImageAndMenu(tab, tab.picActiveImageData);
          return;
        case 'save':
          output(text.picSaving);
          const a = document.createElement('a');
          a.href = tab.picActiveImageData;
          a.download = 'edited-image.jpg';
          a.click();
          break;
        case 'exit':
        case 'quit':
          tab.isPicMode = false;
          tab.picOriginalImageData = null;
          tab.picActiveImageData = null;
          tab.picNextAction = null;
          output(text.leavingPicMode);
          break;
        default:
          output(text.picCommandNotFound);
          break;
      }
      createPrompt(tab);
    }

    function startPlayMode(tab) {
      mediaFileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) {
          createPrompt(tab);
          return;
        }

        const output = (text) => {
          tab.terminalElement.innerHTML += text;
        };

        output('\n');

        if (currentAudioTabId && currentAudioTabId !== tab.id) {
            const oldTab = tabs.find(t => t.id === currentAudioTabId);
            if(oldTab) oldTab.hasAudioControl = false;
        }
        currentAudioTabId = tab.id;

        const oldAudioSrc = audioPlayer.src;
        if (oldAudioSrc && oldAudioSrc.startsWith('blob:')) {
            URL.revokeObjectURL(oldAudioSrc);
        }

        if (file.type.startsWith('audio/')) {
          audioPlayer.src = URL.createObjectURL(file);
          audioPlayer.play();
          tab.hasAudioControl = true;
          output(`${text.playingSound} ${file.name}. ${text.usePauseStop}\n`);
        } else if (file.type.startsWith('video/')) {
          if (tab.videoElement) {
              const oldVideoSrc = tab.videoElement.src;
              if (oldVideoSrc && oldVideoSrc.startsWith('blob:')) {
                  URL.revokeObjectURL(oldVideoSrc);
              }
              tab.videoElement.remove();
          }
          output(`${text.nowPlaying} ${file.name}\n`);

          const videoEl = document.createElement('video');
          videoEl.className = 'terminal-video';
          videoEl.src = URL.createObjectURL(file);
          videoEl.controls = true;
          videoEl.autoplay = true;
          videoEl.tabIndex = -1; // Keep this to prevent focus stealing.

          const refocusTerminalCallback = () => { refocusTerminal(tab); };

          videoEl.onended = () => {
            if (videoEl.src && videoEl.src.startsWith('blob:')) {
                URL.revokeObjectURL(videoEl.src);
            }
            videoEl.remove();
            tab.videoElement = null;
            refocusTerminalCallback();
          };
          videoEl.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
              refocusTerminalCallback();
            }
          });

          tab.terminalElement.appendChild(videoEl);
          tab.videoElement = videoEl;

        } else {
          output(`${text.filetypeNotSupported} '${file.name}' ${text.isNotSupported}`);
        }
        e.target.value = '';
        output('\n');

        createPrompt(tab);

        // Call our new, robust function to ensure focus and scroll are correct.
        refocusTerminal(tab);
      };

      mediaFileInput.value = '';
      setTimeout(() => { mediaFileInput.click(); }, 100);
      setTimeout(() => {
        if (!mediaFileInput.files.length) {
          createPrompt(tab);
        }
      }, 200);
    }


    async function handleCommand(tab, command, internalCall = false) {
      if (!internalCall) {
        const promptLines = tab.terminalElement.querySelectorAll('.prompt-line:last-child');
        const promptLine = promptLines[0];
        if (promptLine) {
          promptLine.innerHTML = `<span>${username}@${config.hostname}:~$ </span><span>${command}</span>\n`;
        }
      }
      const [cmd, ...args] = command.trim().split(' ').filter(Boolean);
      if (!cmd && !internalCall) {
        createPrompt(tab);
        return;
      }
      const arg = args.join(' ');
      const output = (text) => {
        tab.terminalElement.innerHTML += text;
      };

      // Prepend a blank line for all command outputs for readability
      if (cmd.toLowerCase() !== 'say') {
          output('\n');
      }

      if (cmd === "secret") {
        output(text.secretResponse);
        createPrompt(tab);
        return;
      }

      let skipFooter = false;

      switch (cmd.toLowerCase()) {
        case 'say':
          if (!arg) {
            output(text.sayUsage);
          } else if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(arg);
            window.speechSynthesis.speak(utterance);
          } else {
            output(text.sayError);
          }
          skipFooter = true; // Say command skips the standard footer
          break;
        case 'pic':
          startPicMode(tab);
          return;
        case 'play':
          // If already playing audio AND this tab owns control, attempt to resume
          if(currentAudioTabId === tab.id && audioPlayer.src && audioPlayer.paused) {
             audioPlayer.play();
             output(text.resumingSound);
             break;
          }
          // Otherwise, start file picker (which handles control hijacking)
          startPlayMode(tab);
          return;
        case 'pause':
          if (currentAudioTabId !== tab.id) {
             output(text.audioControlError);
             break;
          }
          if (!audioPlayer.paused && audioPlayer.src) {
            audioPlayer.pause();
            output(text.soundPaused);
          } else {
            output("No audio currently playing in this tab's control.\n");
          }
          break;
        case 'stop':
          if (currentAudioTabId !== tab.id) {
             output(text.audioControlError);
             break;
          }
          if (audioPlayer.src) {
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            // Revoke audio blob URL on stop
            if (audioPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(audioPlayer.src);
            }
            audioPlayer.removeAttribute('src');
            tab.hasAudioControl = false;
            currentAudioTabId = null; // Release control
            output(text.soundStopped);
          } else {
            output("No audio currently playing in this tab's control.\n");
          }
          break;
        case 'help':
          output(introText);
          break;
        case 'cls':
        case 'clear':
          playClearSound();
           // Clean up video blob URL before clearing the DOM
          if (tab.videoElement) {
              const videoSrc = tab.videoElement.src;
              if (videoSrc && videoSrc.startsWith('blob:')) {
                  URL.revokeObjectURL(videoSrc);
              }
              tab.videoElement = null;
          }
          tab.terminalElement.innerHTML = '';
          createPrompt(tab);
          return;
        case 'date':
          output(new Date().toLocaleString('en-US'));
          break;
        case 'history':
          tab.commandHistory.forEach((item, index) => {
            output(` ${index + 1} ${item}\n`);
          });
          break;
        case 'calc':
          const safeExpression = /^[0-9\s\+\-\*\/\(\)\.]+$/;
          if (safeExpression.test(arg)) {
            try {
              output(eval(arg));
            } catch (e) {
              output(`Error: ${e.message}`);
            }
          } else {
            output(text.calculatorError);
          }
          break;
        case 'theme':
          if (arg === 'reset') {
            document.documentElement.style.setProperty('--terminal-color', config.defaultColor);
            output(text.colorReset);
          } else if (arg) {
            document.documentElement.style.setProperty('--terminal-color', arg);
            output(text.colorChanged);
          } else {
            // Inform user about usage when no arguments are provided
            output(text.themeUsage);
          }
          break;
        case 'nano':
          startNano(arg);
          return;
        default:
          output(`${text.commandNotFound} ${cmd}\n`);
          break;
      }

      if (!skipFooter) {
        // Append a blank line before the prompt for all commands
        output('\n');
      }
      createPrompt(tab);
    }

    document.body.addEventListener('keydown', async (e) => {
      const tab = getActiveTab();

      if (isNanoMode) return;

      if (e.altKey) {
        if (e.key.toLowerCase() === 't' || e.key.toLowerCase() === 'x') {
          e.preventDefault();
        }
        if (e.key.toLowerCase() === 't') {
          createNewTab();
        } else if (e.key.toLowerCase() === 'x') {
          if (activeTabId) closeTab(activeTabId);
        }
      }
      if (awaitingUsername) {
        e.preventDefault();
        const usernamePromptText = document.getElementById('username-prompt-text');
        if (e.key === 'Enter') {
          playReturnSound();
          username = username.trim() || config.defaultUsername;
          awaitingUsername = false;
          initAudio();
          await startBootSequence();
        } else if (e.key === 'Backspace') {
          username = username.slice(0, -1);
          if (usernamePromptText) usernamePromptText.textContent = username;
        } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
          username += e.key;
          if (usernamePromptText) usernamePromptText.textContent = username;
        }
        return;
      }

      if (!tab || tab.isProcessing) return;

      const isPicModeActive = tab.isPicMode;
      const picNextActionActive = tab.picNextAction;

      if (document.activeElement === tab.terminalElement) {
        e.preventDefault();
        const commandTextEl = tab.terminalElement.querySelector('.prompt-line:last-child .active-command-text');
        if (!commandTextEl) return;
        tab.currentCommand = commandTextEl.textContent;
        if (e.key === 'Enter') {
          playReturnSound();
          if (tab.currentCommand.trim() && !isPicModeActive && !picNextActionActive) {
            tab.commandHistory.push(tab.currentCommand);
          }
          tab.historyIndex = tab.commandHistory.length;

          tab.isProcessing = true;
          if (isPicModeActive) {
            if (picNextActionActive) {
              await handlePicSubCommand(tab.currentCommand, tab);
            } else {
              await handlePicCommand(tab.currentCommand, tab);
            }
          } else {
            await handleCommand(tab, tab.currentCommand);
          }
          tab.isProcessing = false;
        } else if (e.key === 'Backspace') {
          tab.currentCommand = tab.currentCommand.slice(0, -1);
          commandTextEl.textContent = tab.currentCommand;
          playKeySound();
        } else if (e.key === 'ArrowUp' && !isPicModeActive) {
          if (tab.historyIndex > 0) {
            tab.historyIndex--;
            tab.currentCommand = tab.commandHistory[tab.historyIndex];
            commandTextEl.textContent = tab.currentCommand;
          }
        } else if (e.key === 'ArrowDown' && !isPicModeActive) {
          if (tab.historyIndex < tab.commandHistory.length) {
            tab.historyIndex++;
            if (tab.historyIndex < tab.commandHistory.length) {
              tab.currentCommand = tab.commandHistory[tab.historyIndex];
            } else {
              tab.currentCommand = '';
            }
            commandTextEl.textContent = tab.currentCommand;
          }
        } else if (e.key === 'Tab') {
          const parts = tab.currentCommand.split(' ').filter(Boolean);
          if (parts.length === 0) return;
          if (parts.length === 1) {
            const fragment = parts[0].toLowerCase();
            const matches = commandList.filter(cmd => cmd.startsWith(fragment));
            if (matches.length === 1) {
              tab.currentCommand = matches[0] + ' ';
              commandTextEl.textContent = tab.currentCommand;
            } else if (matches.length > 1) {
              const activePromptLine = commandTextEl.parentElement;
              const suggestionsDiv = document.createElement('div');
              suggestionsDiv.textContent = matches.join('    ');
              suggestionsDiv.style.cssText = 'padding-left: 15px; padding-top: 5px; padding-bottom: 5px;';
              tab.terminalElement.insertBefore(suggestionsDiv, activePromptLine);
              // Ensure we scroll down to see the suggestions
              tab.terminalElement.scrollTop = tab.terminalElement.scrollHeight;
            }
          } else if (parts.length >= 2) {
            // No file/folder tab completion anymore.
          }
        } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
          tab.currentCommand += e.key;
          commandTextEl.textContent = tab.currentCommand;
          playKeySound();
        }
      }
    });

    nanoTextarea.addEventListener('keydown', (e) => {
      if (!isNanoMode) return;
      if (e.ctrlKey) {
        const key = e.key.toLowerCase();
        if (key === 'x') {
          e.preventDefault();
          closeNano();
        } else if (key === 'o') {
          e.preventDefault();
          saveNanoFile();
        } else if (key === 'r') {
          e.preventDefault();
          readNanoFile();
        }
      }
    });

    nanoTextarea.addEventListener('paste', async (e) => {
      if (!e.clipboardData || !e.clipboardData.files.length > 0) return;
      const file = e.clipboardData.files[0];
      if (file.type.startsWith('image/')) {
        e.preventDefault();
        const ascii = await convertImageToAscii(file, config.asciiWidth);
        const pos = nanoTextarea.selectionStart;
        const before = nanoTextarea.value.substring(0, pos);
        const after = nanoTextarea.value.substring(pos);
        nanoTextarea.value = before + ascii + after;
      }
    });

    document.body.addEventListener('click', (e) => {
      const tab = getActiveTab();
      if (terminalFrame.contains(e.target) && !tabsContainer.contains(e.target) && tab) {
        // Only refocus if we are not currently clicking on a video player
        if (e.target.tagName.toLowerCase() !== 'video') {
            tab.terminalElement.focus();
        }
      }
    });

    function init() {
      createNewTab();
      const firstTab = getActiveTab();
      firstTab.terminalElement.innerHTML = `<h1>BabeLinux 6.9</h1><div class="prompt-line"><span>${text.welcome} </span><span id="username-prompt-text"></span><span class="cursor"></span></div>\n`;
      firstTab.isProcessing = false;
      firstTab.terminalElement.focus();
    }

    init();
    window.addEventListener('focus', () => {
      const activeTab = getActiveTab();
      if (!document.fullscreenElement && activeTab) {
        activeTab.terminalElement.focus();
      }
    });

    document.body.addEventListener('click', (e) => {
      const activeTab = getActiveTab();
      if (activeTab) {
        const activeEl = document.activeElement.tagName.toLowerCase();
        if (activeEl !== 'input' && activeEl !== 'textarea' && activeEl !== 'video') {
          activeTab.terminalElement.focus();
        }
      }
    });
  </script>
</body>

</html>